#pragma config(Sensor, dgtl1,  LED,            sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  encBL,          sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encBR,          sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  encFL,          sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  encFR,          sensorQuadEncoder)
#pragma config(Motor,  port1,           mLift2,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mBL,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           mBR,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           mIntake,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mFL,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mFR,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mSpin,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           mLift1,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          mBoost,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"


#define __DRIVE_SPEED_FACTOR_SLOW 0.5


void pre_auton() {
  bStopTasksBetweenModes = true;
}


task autonomous() {
}

task flyWheel () {

}

float FL, FR, BL, BR;
float driveFactor = 1.0;
task drive() {
  float maxMotor;
	while (true) {
		if (vexRT[Btn6U]) { // if the acceleration button is pressed...
			driveFactor = 1.0;
		} else {
			driveFactor = __DRIVE_SPEED_FACTOR_SLOW;
		}
    // Death zone s
		if (abs(vexRT[Ch4]) < 20 && abs(vexRT[Ch3]) < 20 && abs(vexRT[Ch1]) < 20) {
			FL = FR = BL = BR = 0;
		} else {
			FL = -vexRT[Ch4] - vexRT[Ch3] - vexRT[Ch1];
			FR = -vexRT[Ch4] + vexRT[Ch3] - vexRT[Ch1];
			BL =  vexRT[Ch4] - vexRT[Ch3] - vexRT[Ch1];
			BR =  vexRT[Ch4] + vexRT[Ch3] - vexRT[Ch1];
		}
		// Make sure th
    // Set each motor to a target speed
		motor[mFL] = FL * driveFactor;
		motor[mFR] = FR * driveFactor;
		motor[mBL] = BL * driveFactor;
		motor[mBR] = BR * driveFactor;
		EndTimeSlice();
	}
}

//task usercontrol()
task main() {
	startTask(drive);
	startTask(flyWheel);
  while (true) {
    EndTimeSlice();
  }
}
